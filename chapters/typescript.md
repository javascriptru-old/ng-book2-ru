# TypeScript {#typescript}

## Angular 4 написан на TypeScript

Angular 4 написан на JavaScript-подобном языке - [TypeScript](http://www.typescriptlang.org/).

Вы можете отнестись скептично к изучению нового языка программирования только для Angular, но оказывается, существует масса весомых аргументов, чтобы использовать именно TypeScript.

Нельзя называть TypeScript совершенно новым языком программирования, это надстройка над ES6. Если мы пишем на ES6, то наш код полностью совместим с TypeScript. Ниже представленна диаграма, показывающая отношения между TypeScript и ES6:

![ES5, ES6, and TypeScript](../images/typescript/es5-es6-typescript-circle-diagram.png)


I> **Что такое ES5? Что такое ES6**? ES5 - короткая форма от "ECMAScript 5", также известная как "обычный JavaScript". ES5 является обычным JavaScript, который мы все знаем и любим. Он может быть выполнен почти во всех браузерах. ES6 - это следующая версия JavaScript, о которой мы поговорим более подробно ниже.

На момент публикации этой книги, только немногие браузеры поддерживали ES6 из коробки, но еще меньше TypeScript. Чтобы решить эту проблему, мы используем транспайлеры (иногда именуемые транскомпиляторами). TypeScript транспайлер берет наш TypeScript код и трансформирует его в ES5 код понятный для большинства браузеров.

I> Для конвертации TypeScript в ES5 существует только один транспайлер написаный командой разработчиков TypeScript. Однако, если мы захотим сконвертировать _ES6_ код (не TypeScript) в _ES5_ существуют 2 основных ES6-ES5 транспайлера: **[traceur](https://github.com/google/traceur-compiler)** от Google и **[babel](https://babeljs.io/)** созданный JavaScript сообществом. В книге мы не планируем использовать ни один из них непосрественно, но это два прекрасных проекта и о них однозначно о них стоит упомянуть.
I>
I> Мы установили TypeScript в предыдущей главе, но если вы решили начать с этой, вот команда для установки:
I>
I> `npm install -g typescript`

TypeScript является результатом сотрудничества Microsoft и Google. Это прекрасная новость, потому что имея за спиной таких гигантов мы можем быть уверены, что технология будет поддерживаться еще долгое время. Обе компании способствуют развитию веба, что не может не радовать нас, разработчиков.

Транспайлеры хороши тем, что они позволяют относительно небольшим командам внедрять улушения уже сейчас при этом не требуя от пользователей обновить браузер.

Хотелось бы подчеркнуть: мы _не обязаны_ использовать TypeScript с Angular4. Если вы хотите использовать ES5 (обычный JavaScript), вы конечно можете. Существует ES5 API, который предоствляет доступ ко всей функциональности Angular4. Но зачем тогда использовать TypeScript? Потому что он позволяет нам использовать возможности, которые делают нашу разработку намного лучше.

## В чем преимущества TypeScript?

Мы можем назвать 5 основных преимуществ, которые предоставляет TypeScript по сравнению с ES5:

- типы
- классы
- аннотации
- импорт
- дополнительные инструменты (деструкция)

Давайте разберем их поочередно.

## Типы

Главное преимущество TypeScript над ES6 это система типов (что и дает называние языку).

Для некоторых разработчиков нестрогая типизация является одним из преимуществ языка JavaScript. Вы можете быть скептично настроены к строгой типизации, но я бы хотел чтобы вы попробовали. Одно из преимуществ строгой типизации то, что

1. она помогает _писать_ код, предотвращая ошибки во время компиляции и
2. она помогает _читать_ код, делая понятной идею

Стоит также отметить, что типы являются опциональными в TypeScript. Если мы хотим написать небольшой сниппет или прототип, мы можем не использовать типы и добавить их только потом, когда код будет готов.

Базовые типы TypeScript точно такие же как те, что мы использовали в обычном JavaScript: строки, числа, булеаны, и т.д.

В ES5, мы объявляем переменную ключевым словом `var`, то есть `var fullName;`.

Новый синтаксис TypeScript является естественным развитием ES5, мы все еще можем пользоваться `var`, но теперь мы можем добавить вместе с именем переменной и также ее тип:

{lang='JavaScript'}
    var fullName: string;

Когда мы объявляем функцию, мы можем использовать типы для аргументов и возвращаемого значения:

{lang='JavaScript'}
    function greetText(fullName: string): string {
      return "Hello " + fullName;
    }

В примере выше мы определили новую функцию `greetText`, содержащую один параметр `fullName`. Синтакс `fullName: string` говорит о том, что функция ожидает получить `fullName` в качестве строки(`string`). Наш код не будет скомпилирован, если мы вызовем эту фукнцию с параметром отличным от строки, и это прекрасно, потому что иначе мы вероятно получим ошибку.

Отметим что функция `greetText` также содержит новый синтаксис после скобок - `: string {`. Двоеточие указывает на то, что мы задаем тип для возвращаемого значения, что в нашем случае строка. Это удобно, потому что 1. если мы случайно вернем что-то отличное от строки, компилятор сообщит нам о ошибке и 2. если другие разработчики захотят использовать эту функцию, то будут знать наверняка что конкретно они получат на выходе.

Давайте посмотрим что будет, если мы попробуем написать код, который не соотвествует объявленым типам:

{lang='JavaScript'}
    function hello(fullName: string): string {
        return 12;
    }

Если мы попробуем скомпилировать этот код, то получим следующую ошибку:

{lang='shell'}
    $ tsc compile-error.ts
    compile-error.ts(2,12): error TS2322: Type 'number' is not assignable to type 'string'.

Что не так? Мы попытались вернуть `12` что является числом(`number`), но заявили что `hello` должна вернуть строку(`string`) указывая `): string {` после объявления аргументов.

Чтобы поправить это, мы должны задать `number` как тип возвращаемого значения:

{lang='JavaScript'}
    function hello(fullName: string): number {
        return 12;
    }

Это только маленький пример, но из него уже видно что использование типов может предотвратить много ошибок в процессе написания кода.

Теперь мы знаем как использовать типы, но как мы можем узнать какие типы мы можем использовать? Давайте взглянем на список встроенных типов, а потом мы разберемся как создавать свои.

### Trying it out with a REPL

Чтобы поиграться с примером из этой главы, установите утилиту, которая называется [**TSUN**](https://github.com/HerringtonDarkholme/typescript-repl) (TypeScript Upgraded Node):

{lang='shell'}
    $ npm install -g tsun

Теперь запустим tsun:

{lang='shell'}
    $ tsun
    TSUN : TypeScript Upgraded Node
    type in TypeScript expression to evaluate
    type :help for commands in repl

    >

Значок `>` говорит нам о том, что TSUN готов к выполнению команд.

В большинстве примеров вы можете просто скопировать код отсюда и вставить с терминал.

## Встроенные типы

#### Строки (String)

Строки содержащие текст объявляются как тип `string`:

{lang='JavaScript'}
    var fullName: string = 'Felipe';

#### Числа (Number)

Здесь мы говорим о всех исчисляемых значениях. В TypeScript все числа представлены как числа с плавающей запятой. Для чисел мы задаем тип `number`:

{lang='JavaScript'}
    var age: number = 36;

#### Булеаны (Boolean)

Тип `boolean` содержит значение `true` либо `false`.

{lang='JavaScript'}
    var married: boolean = true;

#### Массивы (Array)

Массивы объявляются с помощью типа `Array`. Однако, так как массив является коллекцией, мы так же можем задавать тип объектов _в_ массиве.

Мы задаем тип элементов в массиве нотацией `Array<type>` либо `type[]`:

{lang='JavaScript'}
    var jobs: Array<string> = ['IBM', 'Microsoft', 'Google'];
    var jobs: string[] = ['Apple', 'Dell', 'HP'];

то же самое с `number`:

{lang='JavaScript'}
    var chickens: Array<number> = [1, 2, 3];
    var chickens: number[] = [4, 5, 6];

#### Перечисление (Enums)

Перечисляемый тип создан для того чтобы дать привычные имена набору числовых значений. Например: мы бы захотели иметь список возможных ролей пользователя:

{lang='JavaScript'}
    enum Role {Employee, Manager, Admin};
    var role: Role = Role.Employee;

Значение первого элемента 0, но это можно изменить:

{lang='JavaScript'}
    enum Role {Employee = 3, Manager, Admin};
    var role: Role = Role.Employee;

В коде выше мы получим, что `Employee` хранит значение `3`.
В коде ниже, в отличие от `Employee` равным 0, `Employee` будет равен `3`. И далее `Manager` равен `4`, а Admin - `5`, и мы можем задать индивидуальные значения:

{lang='JavaScript'}
    enum Role {Employee = 3, Manager = 5, Admin = 7};
    var role: Role = Role.Employee;

Вы также можете получить имя перечисляемого по его значению:

{lang='JavaScript'}
    enum Role {Employee, Manager, Admin};
    console.log('Roles: ', Role[0], ',', Role[1], 'and', Role[2]);

#### Любой (Any)

`any` являются типом по умолчанию, когда мы не указали тип для переменной. Переменная типа `any` позволяет получать зачение любых типов:

{lang='JavaScript'}
    var something: any = 'as string';
    something = 1;
    something = [1, 2, 3];

#### Void

Когда вы используете `void`, это означает, что вы не ожидаете получить никакого типа. Это обычно применимо для функций без возвращаемого значения:

{lang='JavaScript'}
    function setName(fullName: string): void {
      this.fullName = fullName;
    }

## Классы

В JavaScript версии ES5 мы используем так называемый прототипный подход объектно ориентированное программирование, этот подход использует _прототипы_, а не классы.

JavaScript сообщество разработало ряд решений, которые позволяют компенсировать нехватку классов. Хорошее краткое изложение этих решений можно найти на [Mozilla Developer Network's JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide), и так же вы можете найти общий обзор на [Introduction to Object-Oriented JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript).

Однако, в ES6 наконец-то появляется возможность использовать классы в JavaScript.

Чтобы определить класс мы используем новое ключевое слово `class` и задаем нашему классу имя и содержимое:

{lang='JavaScript'}
    class Vehicle {
    }

Классы могут иметь _свойства_, _методы_, и _конструкторы_.

### Свойсва

Свойства определяют данные закрепленные за экземпляром класса. Например: класс Человек(`Person`) может имеет свойства такие как имя(`first_name`), фамилия(`last_name`) и возраст(`age`).

Каждое свойство класса может иметь тип. Например: мы можем сказать, что имя и фамилия - это строки(`string`), а возраст - числовой тип(`number`).

Объявление класса `Person` будет следующим:

{lang='JavaScript'}
    class Person {
      first_name: string;
      last_name: string;
      age: number;
    }

### Методы

Методы - это функции в контексте объекта. Чтобы вызвать метод объекта, мы сначала должны получить экземпляр этого объекта.

I> Для инициализации класса мы используем ключевое слово `new`, то есть `new Person()` создаст нам экземпляр класса `Person`.

Если мы захотим добавить человеку возможность здороваться, мы вероятно сделаем как-то так:

```javascript
    class Person {
      first_name: string;
      last_name: string;
      age: number;

      // leanpub-start-insert
      greet() {
        console.log("Hello", this.first_name);
      }
      // leanpub-end-insert
    }
```

Отметим, что мы можем получить доступ к свойству `first_name` используя ключевое слово `this` следующим образом `this.first_name`.

Когда тип возвращаемого значения метода не задан, это значит что метод может вернуть что угодно(тип `any`). Однако, в нашем случае мы ничего не возвращаем, поэтому лучше будет указать тип `void` для возвращаемого значения.

I> Учтите что значение `void` также является валидным для типа `any`.

Для того чтобы вызывать метод `greet`, вам нужно иметь экземпляр класса `Person`. Вот как это можно сделать:

```javascript
    // объявляем переменную типа Person
    var p: Person;

    // создаем новую сущность, экземпляр Person
    p = new Person();

    // задаем имя
    p.first_name = 'Felipe';

    // вызываем greet метод
    p.greet();
```

I> Объявление переменной и создание экземпляра класса можно записать в одну строчку:
I>
I> {lang='JavaScript'}
I>     var p: Person = new Person();

Давайте теперь добавим метод, который возвращает значение, например: метод, который нам вернет возраст нашего человека через какое-то количество лет:

```javascript
    class Person {
      first_name: string;
      last_name: string;
      age: number;

      greet() {
        console.log("Hello", this.first_name);
      }

      // leanpub-start-insert
      ageInYears(years: number): number {
        return this.age + years;
      }
      // leanpub-end-insert
    }
```

```javascript
    // создаем новую сущность, экземпляр Person
    var p: Person = new Person();

    // задаем начальный возраст
    p.age = 6;

    // сколько ему будет через 12 лет?
    p.ageInYears(12);

    // -> 18
```

### Конструкторы

Конструктор(_constructor_) является специальным методом, который выполняется, когда мы создаем новый экземпляр класса. Обычно, в конструкторе вы используете какие-то начальные действия по инициализации объекта.

Метод конструктора всегда имет имя `constructor`. Он может принимать входящие параметры, но он не может возвращать значение, так как может быть только вызван при создании экземпляра класса, когда нам возращается сам экземляр.

I> Для создания экземляра класса мы вызываем конструктор метод класса по имени класса: `new ClassName()`.

Если констуктор класса явно не задан, то он будет создан автоматически:

{lang='JavaScript'}
    class Vehicle {
    }
    var v = new Vehicle();

То же самое что и:

{lang='JavaScript'}
    class Vehicle {
      constructor() {
      }
    }
    var v = new Vehicle();

I> В TypeScript класс может имееть только **один конструктор**.
I>
I> Это уход в сторону от ES6, который позволяет классу имееть более одного конструктора, если конктрутор-методы содержат разное число параметров.

Конструктор может принимать параметры в случае, когда мы хотим параметризировать создание экземляра.

Например: мы можем добавить констуктор в класс `Person`, который принимает параметры:

```javascript
    class Person {
      first_name: string;
      last_name: string;
      age: number;

      // leanpub-start-insert
      constructor(first_name: string, last_name: string, age: number) {
        this.first_name = first_name;
        this.last_name = last_name;
        this.age = age;
      }
      // leanpub-end-insert

      greet() {
        console.log("Hello", this.first_name);
      }

      ageInYears(years: number): number {
        return this.age + years;
      }
    }
```

Теперь мы можем записать проще предыдущий пример:

{lang='JavaScript'}
    var p: Person = new Person('Felipe', 'Coury', 36);
    p.greet();

В данном случае имя и возраст задаются во время создания сущности.

### Наследование

Еще один важный концепт объектно ориентированного программирования это наследование. Наследование это способ получения классом поведения родительского класса. Далее мы можем переопределить, изменить или дополнить поведение в новом классе.

I> Если вы хотите получить более глубокое понимание наследование, которое использовалось в ES5, обратите внимание на статью на Mozilla Developer Network -[Наследование и цепочка прототипов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).

TypeScript полностью поддерживает наследование и, в отличие от ES5, это встроенная фукнциональность языка, которая реализуется с помощью ключевого слова `extends`.

Чтобы более нагладно показать, давайте представим что мы создали класс `Report`:

```javascript
    class Report {
      data: Array<string>;

      constructor(data: Array<string>) {
        this.data = data;
      }

      run() {
        this.data.forEach(function(line) { console.log(line); });
      }
    }
```

Этот отчет имеет свойство `data`, которое является массивом строк(`Array<string>`). Когда мы вызываем `run`, мы пробегаем по всем элементам `data` и выводим их в консоль используя метод `console.log`.

I> `.forEach` является методом, который принимает фукнцию как аргумент и вызывает эту функцию для каждого элемента в массиве.

`Report` работает по принципу добавления новых строк и вызова `run`, чтобы вывести эти строки:

{lang='JavaScript'}
    var r: Report = new Report(['First line', 'Second line']);
    r.run();

Должно нам вывести:

{lang='text'}
    First line
    Second line

Теперь давайте представим, что нам нужно сделать второй отчет, который содержит еще заголовки, но при этом сами данные выводятся таким уже образом как и в `Report`.

Чтобы повторно использовать функциональность класса `Report` мы можем сделать наследование от него с помощью ключевого слова `extends`:

```javascript
    class TabbedReport extends Report {
      headers: Array<string>;

      constructor(headers: string[], values: string[]) {
        super(values)
        this.headers = headers;
      }

      run() {
        console.log(this.headers);
        super.run();
      }
    }
```


{lang='JavaScript'}
    var headers: string[] = ['Name'];
    var data: string[] = ['Alice Green', 'Paul Pfifer', 'Louis Blakenship'];
    var r: TabbedReport = new TabbedReport(headers, data)
    r.run();

## Утилиты

ES6 как и TypeScript предоставляют набор синтаксических конструкций, которые делают программирование более приятным. Две важные конструкци:

- функции-стрелки
- fat arrow function syntax
- template strings

### Функции-стрелки

Функция записанная через стрелку `=>` является короткой записью функции.

В ES5, где бы мы не хотели использовать фукнцию как аргумент, нам приходилось использовать ключевое слово `function` вместе с фигурными(`{}`) скобками:

{lang='JavaScript'}
    // ES5-like example
    var data = ['Alice Green', 'Paul Pfifer', 'Louis Blakenship'];
    data.forEach(function(line) { console.log(line); });

Однако с `=>` синтаксисом мы можем записать это так:

{lang='JavaScript'}
    // Typescript example
    var data: string[] = ['Alice Green', 'Paul Pfifer', 'Louis Blakenship'];
    data.forEach( (line) => console.log(line) );

Круглые скобки не обязательны, когда у нас только один параметр. Функции-стрелки мы можем также использовать в выражениях:

{lang='JavaScript'}
    var evens = [2,4,6,8];
    var odds = evens.map(v => v + 1);

или как оператор:

{lang='JavaScript'}
    data.forEach( line => {
      console.log(line.toUpperCase())
    });

Одно важное свойство функций-стрелок, что они оперируют тем же `this` что и код снаружи. Это **важное** отличие от функций созданых с помощью ключевого слова `function`. Как правило, когда вы пишете `function` в JavaScript, функция создает свой собственный `this`. Порой мы встречаем такой JavaScript код:

{lang='JavaScript'}
    var nate = {
      fullName: "Nate",
      guitars: ["Gibson", "Martin", "Taylor"],
      printGuitars: function() {
        var self = this;
        this.guitars.forEach(function(g) {
          // this.fullName is undefined so we have to use self.fullName
          console.log(self.fullName + " plays a " + g);
        });
      }
    };

Так как функция-стрелка использует тот же `this`, что и внешний код, мы можем переписать это как:

{lang='JavaScript'}
    var nate = {
      fullName: "Nate",
      guitars: ["Gibson", "Martin", "Taylor"],
      printGuitars: function() {
        this.guitars.forEach( (g) => {
          console.log(this.fullName + " plays a " + g);
        });
      }
    };

Функции стрелки также прекрасный способ подчистить все ваши встроенные функции. Это делает проще использование функций высшего порядка в JavaScript.

### Строки-шаблоны

В ES6 были представлены строки-шаблоны. Две основные возможности предоставляемые строками-шаблонами:

1. Переменные внутри строк (без конкатенации с `+`) и
2. Возможнсть переноса строки

#### Переменные в строках

Эта возможность так же называется "строковая интерполяция". Идея в том, что вы можете помещать переменные внутри строк, вот так:

{lang='JavaScript'}
    var firstName = "Nate";
    var lastName = "Murray";

    // интерполяция строки
    var greeting = `Hello ${firstName} ${lastName}`;

    console.log(greeting);

Обратите внимание, что для того чтобы использовать строковую интерполяцию необходимо обернуть строку в **обратные ковычки**, не одинарные или двойные.

#### Мультистрочность

Еще одиним преимуществом исползьзования обратных ковычек является возможнсть переноса строки:

{lang='JavaScript'}
    var template = `
    <div>
      <h1>Hello</h1>
      <p>This is a great website</p>
    </div>
    `

    // тут мы что-то делаем со строкой `template`

Благодаря этой возможности мы теперь можем удобно заносить шаблоны в строковые переменные.

## Итоги

Существует еще много других возможнстей TypeScript/ES6, такие как:

- Интерфейсы
- Обобщения (Generics)
- Импорт и Экспорт модулей
- Аннотации
- Деструкция

Мы будет возвращаться к этим концептам на протяжении всей книги, но сейчас этого должно быть достачно для старта.

Давайте вернемся к Angular!
